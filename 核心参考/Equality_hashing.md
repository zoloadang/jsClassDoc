# Equality methods and hashcodes -- 平等方法及散列值 #

### 概述 ###

有多种不同的方法可以判断两个对象是否相等，同时JS.Class针对不同的语义提供了多种平等方法。非常重要的是要了解部分框架的不同之处，并且将一些平等方法进行整合以更方便地使用。

如果你想要使用一个实例对象作为 **Hash** 的键，那么必须要重写它的 `equals()` 和 `hash()` 方法；下面会介绍更多的信息。

----------

### 内置操作符： == 和 === ###

在JS中有两个内置的平等操作符， `==` 代表相等， `===` 代表恒等。例如，当 **foo** 和 **bar** 引用同一个对象时，那么表达式 **foo === bar** 返回 **true** 。对于基本类型(数字类型，字符串型，布尔值等)进行恒等比较时，要确保有相同的值和相同的类型。所以， `'5' === '5'` 返回 **true** ，而 `'5' === 5` 则返回 **false** 。同理，`false === null/false === 0` 皆返回 **false** 。

----------

### 排序位置平等： object.eq(other) ###

该方法由 **[Comparable](../标准库/comparable.md)** 模块提供，当 **object** 和 **other** 拥有相同的排序优先级时返回 **true** 。简单地来理解意思是， **object** 既不是 “小于”，也不是 “大于” **other** 对象，而是指在一个分类集合中的出现顺序的比较。尽管不能直接被使用，但其相关的方法 -- `compareTo()` 常被 **[Hash](../标准库/hash.md)** 和 **[SortedSet](../标准库/sortedset.md)** 用来排列对象。

----------

### 等值：object.equals(other) ###

只有当 **object** 和 **other** 两个对象属于逻辑上相等时才返回 `true` 。使用恒等式 `===` 来比较对象时，默认使用的就是内核([Kernel](./kernel.md))中的该方法；类可以覆盖该方法以提供更丰富的逻辑比较。例如， **[Set#equals](../标准库/set.md)()** 方法返回true的条件是，比较两个集合中是否包含相同的成员。下面的类展现的是对象实现 **equals()** 方法的条件：

- **Hash** 类使用 `equals()` 方法确保键是唯一值，如果键不存在相等项事则再使用恒等式进行比较。详情可以查看下面介绍的 **object.hash()** 。

- **Range** 类使用 `equals()` 方法来检验两个区间的端点是否在其自己的 `equals()` 方法中是相同的。使用 **compareTo()** 方法来检查当使用 **forEach()** 迭代时是否在区间内存在或已经溢出了区间。

- **Set** 类使用 `equals()` 方法来检验没有重复的元素存在，如果没有重复元素时则接下来使用恒等式进行比较。

JS.Class没有修改任何内置的JS类，但是上面提到的类中包含一些用来比较数组和对象的方法。两个数组之间进行比较时，如果它们各自的元素全部都相等时就认为这两个数组是相等的。而当两个不支持 `equals()` 方法的对象进行比较时，它们拥有完全相同的的键值对时则被认为是相等的。

如果想要在自定义的类中实现 `equals()` 方法的话，需要遵守以下这些规则：

- **自反性：** `x.equals(x)` 一定会返回 true

- **对称性：** 如果 `x.equals(y)` 返回 true，那么 `y.equals(x)` 也一定返回 true

- **传递性：** 如果 `x.equals(y)` 返回 true 而且 `y.equals(x)` 也返回 true，那么 `x.equals(z)` 也一定是 true

- **一致性：** 根据 x 和 y 的状态改变， `x.equals(y)` 会一致地返回 true/false

- 对象不等于 **null** ; `x.equals(y)` 会一直返回 false

> 如果想要得到 `x.equals(y)` 返回 true, 且 `x.hash() === y.hash()` 也返回 true 这样的结果时，则必须要重写 **hash()** 方法，否则你想在 **Hash** 中使用对象作为键来使用是会出问题的。 


----------

### 哈希平等： object.hash() ###

**hash()** 方法常作为 `Hash` 类的内部方法使用以提升关键搜索性能，实现原理是按照存储的键值对进行分隔并分别装入类似"水桶"区域，然后为每个“水桶”分配一个哈希代码。(更多信息可以查看Wikipedia中关于[哈希表的工作方式](http://en.wikipedia.org/wiki/Hash_table)进行了解) 当想要通过一个给定的键来访问 **Hash** 对象中对应的值时，就可以通过将键转换成哈希代码，然后找到对应的“水桶”并取出里面的值。

调用内核中的 `hash()` 方法会为每个对象产生一个不同的值。如果在你的类中实现 `equals()` 方法而且两个对象也被认为是相等时，那么必须要确定两个相等的对象返回一样的哈希代码；两个相等对象根据给定的键应该得到一样的值，但如果是不同的哈希代码，那么就去不同的地方寻找它们各自的值。

因此，如果你要类中实现 `equals()` 方法，则必须同时要按如下方式来实现 `hash()` 方法：

- `x.hash()` 不带参数并且会返回一个关于 **x** 状态的字符信息

- 只要 **x** 的状态没有修改，那么每次调用 `x.hash()` 方法都会返回同样的值

- 如果两个对象是相等的，可以通过 `x.equals(y)`， 然后 `x.hash()` 和 `y.hash()` 都返回相同的值

- 如果两个对象不相等，也不一定非要返回不同的哈希值，尽管这样可以很大地提升哈希表的性能。
